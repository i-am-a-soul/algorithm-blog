# 矩阵快速幂

## 原理

见《进阶指南》第`156`页。

## 模板题

[洛谷-P3390-【模板】矩阵快速幂](https://www.luogu.com.cn/problem/P3390)

```cpp
#include <iostream>
#include <cstring>
using namespace std;

typedef long long LL;
const int N = 110, M = 1e9 + 7;
struct matrix {
    static int n;
    int m[N][N];

    matrix () {
        memset(m, 0, sizeof(m));
    }
    friend matrix operator * (const matrix& a, const matrix& b) {
        matrix res;
        for (int i = 1; i <= n; ++ i)
            for (int k = 1; k <= n; ++ k) // 优化
                for (int j = 1; j <= n; ++ j)
                    res.m[i][j] = (res.m[i][j] + (LL)a.m[i][k] * b.m[k][j] % M) % M;
        return res;
    }
    friend matrix operator ^ (matrix a, LL b) {
        matrix res;
        for (int i = 1; i <= n; ++ i) res.m[i][i] = 1;
        while (b > 0) {
            if (b & 1) res = res * a;
            a = a * a;
            b /= 2;
        }
        return res;
    }
};
int matrix::n = 0;

int main () {
    int n;
    LL k;
    scanf("%d%lld", &n, &k);

    matrix::n = n;
    matrix A;
    for (int i = 1; i <= n; ++ i)
        for (int j = 1; j <= n; ++ j)
            scanf("%d", &A.m[i][j]);
    
    matrix res = A ^ k;
    for (int i = 1; i <= n; ++ i) {
        for (int j = 1; j <= n; ++ j)
            printf("%d ", res.m[i][j]);
        printf("\n");
    }
    return 0;
}
```
